---
import MainLayout from '../layouts/MainLayout.astro';
import ProductCard from '../components/molecules/ProductCard.astro';
import Button from '../components/atoms/Button.astro';
import Spinner from '../components/atoms/Spinner.astro';
import { getProducts } from '../lib/wc-api';

const url = Astro.url;
const searchParams = url.searchParams;
const search = searchParams.get('search') || '';
const perPageWC = 100; // Charger plus de produits de WooCommerce pour compenser la déduplication
const displayPerPage = 20; // Afficher 20 produits uniques (4 lignes de 5)

let products = [];

try {
  const params: Record<string, string> = {
    per_page: perPageWC.toString(),
    page: '1',
  };
  
  if (search) {
    params.search = search;
  }
  
  const response = await getProducts(params);
  const allProducts = Array.isArray(response) ? response : [];
  
  // Grouper les produits par titre (insensible à la casse) et ne garder qu'un seul produit par groupe
  const productsByTitle = new Map<string, any>();
  
  allProducts.forEach((product: any) => {
    const productName = (product.name || '').trim().toLowerCase();
    
    // Optimiser l'URL de l'image - réduire la taille pour un chargement plus rapide
    if (product.images && product.images.length > 0 && product.images[0].src) {
      // WooCommerce permet de spécifier la taille dans l'URL
      const imgUrl = product.images[0].src;
      // Remplacer la taille par 'medium' (généralement 300x300) au lieu de 'large'
      product.images[0].src = imgUrl.replace(/\.(jpg|jpeg|png|gif|webp)/i, '-300x300.$1');
    }
    
    // Si on n'a pas encore de produit pour ce titre, ou si le produit actuel est en stock et l'autre non
    if (!productsByTitle.has(productName)) {
      productsByTitle.set(productName, product);
    } else {
      const existingProduct = productsByTitle.get(productName);
      const existingIsOutOfStock = existingProduct.stock_status === 'out_of_stock' || existingProduct.stock_status === 'outofstock';
      const currentIsOutOfStock = product.stock_status === 'out_of_stock' || product.stock_status === 'outofstock';
      
      // Préférer le produit en stock, sinon garder celui avec le plus petit ID (premier créé)
      if (existingIsOutOfStock && !currentIsOutOfStock) {
        productsByTitle.set(productName, product);
      } else if (!existingIsOutOfStock && currentIsOutOfStock) {
        // Garder l'existant
      } else if (product.id < existingProduct.id) {
        // Si même statut de stock, garder celui avec le plus petit ID
        productsByTitle.set(productName, product);
      }
    }
  });
  
  // Convertir la Map en tableau, trier par ID et limiter à displayPerPage
  products = Array.from(productsByTitle.values())
    .sort((a: any, b: any) => a.id - b.id)
    .slice(0, displayPerPage);
} catch (error) {
  console.error('Error fetching products:', error);
  products = [];
}
---

<MainLayout title="Catalog" description="Discover our complete catalog of aeronautical products">
  <div class="container mx-auto px-4 py-8">
    <!-- Products Grid -->
    <div id="products-container">
      {products.length > 0 ? (
        <div id="products-grid" class="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 sm:gap-4 md:gap-6 mb-8">
          {products.map((product) => (
            <ProductCard product={product} />
          ))}
        </div>
      ) : (
        <div class="text-center py-12">
          <p class="font-outfit text-gray-500 dark:text-gray-400 text-lg mb-4">
            {search ? 'No products found for your search' : 'No products available'}
          </p>
          {search && (
            <Button href="/catalogue" variant="primary">
              View all catalog
            </Button>
          )}
        </div>
      )}
      
      <!-- Loading indicator -->
      <div id="loading-indicator" class="hidden text-center py-8">
        <div class="flex flex-col items-center justify-center gap-4">
          <Spinner size="md" />
          <p class="font-outfit text-gray-600 dark:text-gray-400">Loading products...</p>
        </div>
      </div>
      
      <!-- End of products message -->
      <div id="end-message" class="hidden text-center py-8">
        <p class="font-outfit text-gray-500 dark:text-gray-400">All products have been loaded</p>
      </div>
    </div>
  </div>
</MainLayout>

<script>
  (function() {
    const productsGrid = document.getElementById('products-grid');
    const loadingIndicator = document.getElementById('loading-indicator');
    const endMessage = document.getElementById('end-message');
    
    if (!productsGrid) return;
    
    let currentPage = 1;
    let isLoading = false;
    let hasMore = true;
    const searchQuery = new URLSearchParams(window.location.search).get('search') || '';
    const perPageWC = 100; // Charger beaucoup de produits de WooCommerce
    const displayPerLoad = 20; // Afficher 20 produits uniques par chargement (4 lignes de 5)
    let loadedProductNames = new Set(); // Pour éviter les doublons entre les chargements
    
    // Initialiser avec les noms des produits déjà affichés
    document.querySelectorAll('[data-product-name]').forEach(el => {
      const name = el.getAttribute('data-product-name')?.trim().toLowerCase();
      if (name) loadedProductNames.add(name);
    });
    
    // Observer pour détecter quand l'utilisateur arrive en bas de page
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && hasMore && !isLoading) {
          loadMoreProducts();
        }
      });
    }, {
      rootMargin: '200px', // Commencer à charger 200px avant d'arriver en bas
    });
    
    // Créer un élément sentinelle pour observer
    const sentinel = document.createElement('div');
    sentinel.id = 'scroll-sentinel';
    sentinel.className = 'h-1';
    productsGrid.parentNode?.appendChild(sentinel);
    observer.observe(sentinel);
    
    async function loadMoreProducts() {
      if (isLoading || !hasMore) return;
      
      isLoading = true;
      currentPage++;
      
      // Afficher l'indicateur de chargement
      if (loadingIndicator) {
        loadingIndicator.classList.remove('hidden');
      }
      
      try {
        const params = new URLSearchParams({
          page: currentPage.toString(),
        });
        
        if (searchQuery) {
          params.append('search', searchQuery);
        }
        
        const response = await fetch(`/catalogue/load?${params.toString()}`);
        const html = await response.text();
        
        if (html && html.trim().length > 0) {
          // Parser le HTML retourné
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = html;
          
          // Le premier élément contient les attributs data
          const wrapper = tempDiv.firstElementChild;
          const hasMoreData = wrapper?.getAttribute('data-has-more') === 'true';
          const count = parseInt(wrapper?.getAttribute('data-count') || '0');
          
          // Récupérer tous les ProductCard (enfants du wrapper)
          const newCards = wrapper?.children || [];
          
          if (newCards.length > 0) {
            // Ajouter chaque ProductCard à la grille
            Array.from(newCards).forEach(card => {
              productsGrid.appendChild(card);
            });
            
            // Continuer seulement si WooCommerce a retourné le maximum de produits (100)
            // Ce qui signifie qu'il y a probablement une page suivante
            hasMore = hasMoreData;
          } else {
            hasMore = false;
          }
        } else {
          hasMore = false;
        }
        
        // Si plus de produits, afficher le message de fin
        if (!hasMore && endMessage) {
          endMessage.classList.remove('hidden');
          if (sentinel) {
            observer.unobserve(sentinel);
          }
        }
      } catch (error) {
        console.error('Error loading more products:', error);
        hasMore = false;
      } finally {
        isLoading = false;
        if (loadingIndicator) {
          loadingIndicator.classList.add('hidden');
        }
      }
    }
  })();
</script>

