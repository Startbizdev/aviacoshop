---
import MainLayout from '../layouts/MainLayout.astro';
import ProductCard from '../components/molecules/ProductCard.astro';
import Button from '../components/atoms/Button.astro';
import Spinner from '../components/atoms/Spinner.astro';
import { getProducts } from '../lib/wc-api';

const url = Astro.url;
const searchParams = url.searchParams;
const search = searchParams.get('search') || '';
const perPageWC = 100; // Charger plus de produits de WooCommerce pour compenser la déduplication
const displayPerPage = 20; // Afficher 20 produits uniques (4 lignes de 5)

let products = [];

try {
  const params: Record<string, string> = {
    per_page: perPageWC.toString(),
    page: '1',
  };
  
  if (search) {
    params.search = search;
  }
  
  const response = await getProducts(params);
  const allProducts = Array.isArray(response) ? response : [];
  
  // Log pour déboguer le chargement initial
  console.log(`Page initiale: ${allProducts.length} produits bruts reçus de WooCommerce`);
  
  // Grouper les produits par titre (insensible à la casse) et ne garder qu'un seul produit par groupe
  const productsByTitle = new Map<string, any>();
  
  allProducts.forEach((product: any) => {
    const productName = (product.name || '').trim().toLowerCase();
    
    // Utiliser l'URL originale de l'image telle quelle (pas de modification)
    
    // Si on n'a pas encore de produit pour ce titre, ou si le produit actuel est en stock et l'autre non
    if (!productsByTitle.has(productName)) {
      productsByTitle.set(productName, product);
    } else {
      const existingProduct = productsByTitle.get(productName);
      const existingIsOutOfStock = existingProduct.stock_status === 'out_of_stock' || existingProduct.stock_status === 'outofstock';
      const currentIsOutOfStock = product.stock_status === 'out_of_stock' || product.stock_status === 'outofstock';
      
      // Préférer le produit en stock, sinon garder celui avec le plus petit ID (premier créé)
      if (existingIsOutOfStock && !currentIsOutOfStock) {
        productsByTitle.set(productName, product);
      } else if (!existingIsOutOfStock && currentIsOutOfStock) {
        // Garder l'existant
      } else if (product.id < existingProduct.id) {
        // Si même statut de stock, garder celui avec le plus petit ID
        productsByTitle.set(productName, product);
      }
    }
  });
  
  // Convertir la Map en tableau, trier par ID
  // Ne pas limiter ici - afficher tous les produits uniques de cette page
  products = Array.from(productsByTitle.values())
    .sort((a: any, b: any) => a.id - b.id);
  
  // Log pour déboguer après déduplication
  console.log(`Page initiale: ${products.length} produits uniques après déduplication (sur ${allProducts.length} bruts)`);
} catch (error) {
  console.error('Error fetching products:', error);
  products = [];
}
---

<MainLayout title="Catalog" description="Discover our complete catalog of aeronautical products">
  <div class="container mx-auto px-4 py-8">
    <!-- Products Grid -->
    <div id="products-container">
      {products.length > 0 ? (
        <div id="products-grid" class="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 sm:gap-4 md:gap-6 mb-8">
          {products.map((product) => (
            <ProductCard product={product} />
          ))}
        </div>
      ) : (
        <div class="text-center py-12">
          <p class="font-outfit text-gray-500 dark:text-gray-400 text-lg mb-4">
            {search ? 'No products found for your search' : 'No products available'}
          </p>
          {search && (
            <Button href="/catalogue" variant="primary">
              View all catalog
            </Button>
          )}
        </div>
      )}
      
      <!-- Loading indicator -->
      <div id="loading-indicator" class="hidden text-center py-8">
        <div class="flex flex-col items-center justify-center gap-4">
          <Spinner size="md" />
          <p class="font-outfit text-gray-600 dark:text-gray-400">Loading products...</p>
        </div>
      </div>
      
      <!-- End of products message -->
      <div id="end-message" class="hidden text-center py-8">
        <p class="font-outfit text-gray-500 dark:text-gray-400">All products have been loaded</p>
      </div>
    </div>
  </div>
</MainLayout>

<script>
  (function() {
    const productsGrid = document.getElementById('products-grid');
    const loadingIndicator = document.getElementById('loading-indicator');
    const endMessage = document.getElementById('end-message');
    
    if (!productsGrid) return;
    
    let currentPage = 1;
    let isLoading = false;
    const searchQuery = new URLSearchParams(window.location.search).get('search') || '';
    
    // Déterminer s'il y a plus de produits à charger en fonction du nombre de produits bruts reçus
    // Si on a reçu exactement 100 produits bruts, il y a probablement plus de pages
    // Si on a reçu moins de 100 produits bruts, c'est peut-être la dernière page, mais on essaie quand même
    const initialProductCount = productsGrid.children.length;
    // Si on a moins de 100 produits affichés mais qu'on ne fait pas de recherche,
    // on suppose qu'il y a peut-être plus de produits (car la déduplication peut réduire le nombre)
    let hasMore = !searchQuery || initialProductCount >= 100;
    
    console.log(`Initialisation: ${initialProductCount} produits affichés, hasMore initial: ${hasMore}, recherche: "${searchQuery}"`);
    const perPageWC = 100; // Charger beaucoup de produits de WooCommerce
    const displayPerLoad = 20; // Afficher 20 produits uniques par chargement (4 lignes de 5)
    let loadedProductNames = new Set(); // Pour éviter les doublons entre les chargements
    
    // Initialiser avec les noms des produits déjà affichés
    document.querySelectorAll('[data-product-name]').forEach(el => {
      const name = el.getAttribute('data-product-name')?.trim().toLowerCase();
      if (name) loadedProductNames.add(name);
    });
    
    // Observer pour détecter quand l'utilisateur arrive en bas de page
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && hasMore && !isLoading) {
          loadMoreProducts();
        }
      });
    }, {
      rootMargin: '200px', // Commencer à charger 200px avant d'arriver en bas
    });
    
    // Créer un élément sentinelle pour observer
    const sentinel = document.createElement('div');
    sentinel.id = 'scroll-sentinel';
    sentinel.className = 'h-1';
    productsGrid.parentNode?.appendChild(sentinel);
    observer.observe(sentinel);
    
    async function loadMoreProducts() {
      if (isLoading || !hasMore) return;
      
      isLoading = true;
      currentPage++;
      
      // Afficher l'indicateur de chargement
      if (loadingIndicator) {
        loadingIndicator.classList.remove('hidden');
      }
      
      try {
        const params = new URLSearchParams({
          page: currentPage.toString(),
        });
        
        if (searchQuery) {
          params.append('search', searchQuery);
        }
        
        const response = await fetch(`/catalogue/load?${params.toString()}`);
        const html = await response.text();
        
        if (html && html.trim().length > 0) {
          // Parser le HTML retourné (peut être un document HTML complet ou un fragment)
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          
          // Chercher le wrapper avec les attributs data dans le document
          let wrapper = doc.querySelector('[data-has-more]') as HTMLElement | null;
          let hasMoreData = false;
          let count = 0;
          let uniqueCount = 0;
          
          if (wrapper) {
            hasMoreData = wrapper.getAttribute('data-has-more') === 'true';
            count = parseInt(wrapper.getAttribute('data-count') || '0');
            uniqueCount = parseInt(wrapper.getAttribute('data-unique-count') || '0');
          }
          
          // Log pour déboguer le parsing
          console.log(`[Client] HTML reçu - longueur: ${html.length}, wrapper existe: ${!!wrapper}, tagName: ${wrapper?.tagName}`);
          console.log(`[Client] Attributs data - hasMore: ${hasMoreData}, count: ${count}, uniqueCount: ${uniqueCount}`);
          console.log(`[Client] Nombre d'enfants du wrapper: ${wrapper?.children?.length || 0}`);
          
          // Récupérer tous les ProductCard (enfants directs du wrapper)
          // ProductCard génère un <a> via le composant Card
          let newCards: Element[] = [];
          if (wrapper) {
            // Les ProductCard sont des enfants directs du wrapper (des éléments <a> générés par Card)
            // Prendre tous les enfants directs qui ne sont pas des scripts ou des commentaires
            newCards = Array.from(wrapper.children).filter(child => {
              // Exclure les scripts et autres éléments non-product
              return child.tagName !== 'SCRIPT' && 
                     child.tagName !== 'STYLE' &&
                     child.tagName !== 'NOSCRIPT' &&
                     !child.hasAttribute('data-astro');
            });
          }
          
          // Log détaillé des cartes trouvées
          console.log(`[Client] ${newCards.length} ProductCard trouvés dans le HTML`);
          if (newCards.length === 0 && wrapper) {
            console.warn(`[Client] Aucune carte trouvée mais wrapper existe. Structure HTML:`, wrapper.outerHTML.substring(0, 500));
          }
          
          // Ajouter chaque ProductCard à la grille même s'il n'y en a pas beaucoup
          // (après déduplication, une page peut avoir peu ou pas de nouveaux produits uniques)
          if (newCards.length > 0) {
            Array.from(newCards).forEach(card => {
              productsGrid.appendChild(card);
            });
            
            // Vérifier l'authentification et attacher les listeners pour les nouveaux produits ajoutés
            // Utiliser setTimeout pour s'assurer que le DOM est mis à jour
            setTimeout(() => {
              if ((window as any).checkProductAuth) {
                (window as any).checkProductAuth();
              }
              if ((window as any).attachAddToCartListeners) {
                (window as any).attachAddToCartListeners();
              }
              // Déclencher aussi l'événement personnalisé
              window.dispatchEvent(new Event('products-loaded'));
            }, 0);
          }
          
          // Log pour déboguer - afficher aussi le nombre total de produits dans la grille
          const totalProductsInGrid = productsGrid.children.length;
          console.log(`Page ${currentPage}: ${newCards.length} nouveaux produits uniques, ${totalProductsInGrid} total dans la grille, hasMore: ${hasMoreData}, produits WC bruts: ${count}`);
          
          // Logique de pagination améliorée :
          // - Si on reçoit 0 produits bruts (count === 0) ET 0 ProductCard, il n'y a vraiment plus de produits
          // - Si on reçoit exactement 100 produits bruts, il y a probablement une page suivante
          // - Si on reçoit moins de 100 mais > 0 produits bruts, c'est peut-être la dernière page
          //   MAIS on continue quand même à charger au cas où il y aurait encore des pages
          //   (car après déduplication, on peut avoir moins de 100 produits uniques même s'il y a plus de pages)
          // - Si count est 0 mais qu'on a des ProductCard, c'est que le parsing des attributs a échoué,
          //   mais on continue quand même car il y a des produits
          
          if (count === 0 && newCards.length === 0) {
            // Aucun produit brut ET aucune carte = vraiment la fin
            hasMore = false;
            console.log(`Page ${currentPage}: 0 produits bruts ET 0 cartes reçus, fin du chargement`);
          } else if (count === 100) {
            // Exactement 100 produits = il y a probablement une page suivante
            hasMore = true;
            console.log(`Page ${currentPage}: 100 produits bruts reçus, continuation du chargement`);
          } else if (count > 0 && count < 100) {
            // Moins de 100 produits mais > 0 = dernière page probable, mais on essaie quand même la suivante
            // On s'arrête seulement si la page suivante retourne 0 produits
            hasMore = true;
            console.log(`Page ${currentPage}: ${count} produits bruts (< 100), on essaie quand même la page suivante`);
          } else if (count === 0 && newCards.length > 0) {
            // Count est 0 mais on a des cartes = parsing des attributs a échoué, mais on continue
            hasMore = true;
            console.log(`Page ${currentPage}: count=0 mais ${newCards.length} cartes trouvées, continuation (parsing attributs peut avoir échoué)`);
          } else {
            // Cas par défaut : continuer si on a des cartes
            hasMore = newCards.length > 0;
            console.log(`Page ${currentPage}: Cas par défaut - count: ${count}, cartes: ${newCards.length}, hasMore: ${hasMore}`);
          }
        } else {
          // Si la réponse HTML est vide, il n'y a vraiment plus de produits
          hasMore = false;
          console.log(`Page ${currentPage}: Réponse HTML vide, fin du chargement`);
        }
        
        // Si plus de produits, afficher le message de fin
        // Mais seulement si on a vraiment reçu 0 produits bruts (pas juste hasMoreData = false)
        if (!hasMore && endMessage) {
          console.log(`Affichage du message "All products have been loaded" - hasMore: ${hasMore}, total produits: ${productsGrid.children.length}`);
          endMessage.classList.remove('hidden');
          if (sentinel) {
            observer.unobserve(sentinel);
          }
        }
      } catch (error) {
        console.error('Error loading more products:', error);
        hasMore = false;
      } finally {
        isLoading = false;
        if (loadingIndicator) {
          loadingIndicator.classList.add('hidden');
        }
      }
    }
  })();
</script>

